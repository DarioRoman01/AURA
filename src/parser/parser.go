package parser

import (
	"fmt"
	"katan/src/ast"
	l "katan/src/lexer"
	"strconv"
)

type PrefixParsFn func() ast.Expression
type SuffixParseFn func(ast.Expression) ast.Expression
type InfixParseFn func(ast.Expression) ast.Expression

type PrefixParsFns map[l.TokenType]PrefixParsFn
type InfixParseFns map[l.TokenType]InfixParseFn
type SuffixParseFns map[l.TokenType]SuffixParseFn

type Precedence int

const (
	HeadPrecendence Precedence = iota
	LOWEST                     = 1
	ANDOR                      = 2
	EQUEAL                     = 3
	LESSGRATER                 = 4
	SUM                        = 5
	PRODUCT                    = 6
	PREFIX                     = 7
	CALL                       = 8
)

var PRECEDENCES = map[l.TokenType]Precedence{
	l.AND:         ANDOR,
	l.EQ:          EQUEAL,
	l.NOT_EQ:      EQUEAL,
	l.LT:          LESSGRATER,
	l.LTOREQ:      LESSGRATER,
	l.GT:          LESSGRATER,
	l.GTOREQ:      LESSGRATER,
	l.PLUS:        SUM,
	l.MINUS:       SUM,
	l.DIVISION:    PRODUCT,
	l.TIMES:       PRODUCT,
	l.MOD:         PRODUCT,
	l.LPAREN:      CALL,
	l.LBRACKET:    CALL,
	l.OR:          ANDOR,
	l.ASSING:      ANDOR,
	l.COLON:       CALL,
	l.PLUSASSING:  PRODUCT,
	l.MINUSASSING: PRODUCT,
	l.DIVASSING:   PRODUCT,
	l.EXPONENT:    PRODUCT,
	l.TIMEASSI:    PRODUCT,
	l.PLUS2:       PRODUCT,
	l.MINUS2:      PRODUCT,
}

// parser handle the parsing of the program staments and syntax of the program
type Parser struct {
	lexer          *l.Lexer
	currentToken   *l.Token
	peekToken      *l.Token
	errors         []string
	prefixParsFns  PrefixParsFns
	infixParseFns  InfixParseFns
	suffixParseFns SuffixParseFns
}

// generates a new parser instance
func NewParser(lexer *l.Lexer) *Parser {
	parser := &Parser{
		lexer:        lexer,
		currentToken: nil,
		peekToken:    nil,
	}

	parser.prefixParsFns = parser.registerPrefixFns()
	parser.infixParseFns = parser.registerInfixFns()
	parser.suffixParseFns = parser.registerSuffixFns()
	parser.advanceTokens()
	parser.advanceTokens()
	return parser
}

// advance 1 in the tokens generated by the lexer
func (p *Parser) advanceTokens() {
	p.currentToken = p.peekToken
	nextToken := p.lexer.NextToken()
	p.peekToken = &nextToken
}

// check that the current token is not nil
func (p *Parser) checkCurrentTokenIsNotNil() {
	defer p.handlePeekTokenPanic()
	if p.currentToken == nil {
		panic("Ocurrio un error mientras se parseaba")
	}
}

// check that the peek token is not nil
func (p *Parser) checkPeekTokenIsNotNil() {
	defer p.handlePeekTokenPanic()
	if p.peekToken == nil {
		panic("Ocurrio un error mientras se parseaba")
	}
}

func (p *Parser) handlePeekTokenPanic() {
	if r := recover(); r != nil {
		fmt.Println("Error: ", r)
	}
}

// check precedence of the current token
func (p *Parser) currentPrecedence() Precedence {
	p.checkCurrentTokenIsNotNil()
	precedence, exists := PRECEDENCES[p.currentToken.Token_type]
	if !exists {
		return LOWEST
	}

	return precedence
}

// return the error list in the parser
func (p *Parser) Errors() []string {
	return p.errors
}

// parse all program staments
func (p *Parser) ParseProgam() ast.Program {
	program := ast.Program{Staments: []ast.Stmt{}}

	for p.currentToken.Token_type != l.EOF {
		statement := p.parseStament()
		if statement != nil {
			program.Staments = append(program.Staments, statement)
		}

		p.advanceTokens()
	}
	return program
}

// expectedToken will check if the peek token is the correct type
// based on the parameter
func (p *Parser) expepectedToken(tokenType l.TokenType) bool {
	if p.peekToken.Token_type == tokenType {
		p.advanceTokens()
		return true
	}

	p.expectedTokenError(tokenType)
	return false
}

// add a error to errors list if there is any unexpected token error
func (p *Parser) expectedTokenError(tokenType l.TokenType) {
	p.checkCurrentTokenIsNotNil()
	err := fmt.Sprintf(
		"se esperaba que el siguient token fuera %s pero se obtuvo %s",
		l.Tokens[tokenType],
		l.Tokens[p.peekToken.Token_type],
	)
	p.errors = append(p.errors, err)
}

// parse boolean expression and check if true or false
func (p *Parser) parseBoolean() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	var value bool
	if p.currentToken.Token_type == l.TRUE {
		value = true
		return ast.NewBoolean(*p.currentToken, &value)
	}

	value = false
	return ast.NewBoolean(*p.currentToken, &value)
}

// parse a block of staments
func (p *Parser) parseBlock() *ast.Block {
	p.checkCurrentTokenIsNotNil()
	blockStament := ast.NewBlock(*p.currentToken)
	p.advanceTokens()

	for !(p.currentToken.Token_type == l.RBRACE) && !(p.currentToken.Token_type == l.EOF) {
		stament := p.parseStament()
		if stament != nil {
			blockStament.Staments = append(blockStament.Staments, stament)
		}

		p.advanceTokens()
	}

	return blockStament
}

// parse function calls
func (p *Parser) parseCall(function ast.Expression) ast.Expression {
	p.checkCurrentTokenIsNotNil()
	call := ast.NewCall(*p.currentToken, function)
	call.Arguments = p.parseCallArguments()
	return call
}

func (p *Parser) ParseArray() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	arr := ast.NewArray(*p.currentToken, nil)
	if !p.expepectedToken(l.LBRACKET) {
		return nil
	}

	arr.Values = p.ParseArrayValues()
	return arr
}

func (p *Parser) ParseArrayValues() []ast.Expression {
	p.checkCurrentTokenIsNotNil()
	var values []ast.Expression
	if p.peekToken.Token_type == l.RBRACKET {
		p.advanceTokens()
		return values
	}

	p.advanceTokens()
	if expression := p.parseExpression(LOWEST); expression != nil {
		values = append(values, expression)
	}

	for p.peekToken.Token_type == l.COMMA {
		p.advanceTokens()
		p.advanceTokens()
		if expression := p.parseExpression(LOWEST); expression != nil {
			values = append(values, expression)
		}
	}

	if !p.expepectedToken(l.RBRACKET) {
		return nil
	}

	return values
}

// parse args in function calls
func (p *Parser) parseCallArguments() []ast.Expression {
	var args []ast.Expression
	p.checkPeekTokenIsNotNil()
	if p.peekToken.Token_type == l.RPAREN {
		p.advanceTokens()
		return args
	}

	p.advanceTokens()
	if expression := p.parseExpression(LOWEST); expression != nil {
		args = append(args, expression)
	}

	for p.peekToken.Token_type == l.COMMA {
		p.advanceTokens()
		p.advanceTokens()
		if expression := p.parseExpression(LOWEST); expression != nil {
			args = append(args, expression)
		}
	}

	if !p.expepectedToken(l.RPAREN) {
		return nil
	}

	return args
}

// parse a expression and check if there is a valid expression
func (p *Parser) parseExpression(precedence Precedence) ast.Expression {
	defer p.handlePeekTokenPanic()
	p.checkCurrentTokenIsNotNil()
	prefixParseFn, exist := p.prefixParsFns[p.currentToken.Token_type]
	if !exist {
		message := fmt.Sprintf("no se encontro ninguna funcion para parsear %s", p.currentToken.Literal)
		p.errors = append(p.errors, message)
		return nil
	}

	leftExpression := prefixParseFn()
	p.checkPeekTokenIsNotNil()

	if suffixFn, exists := p.suffixParseFns[p.peekToken.Token_type]; exists {
		p.advanceTokens()
		leftExpression = suffixFn(leftExpression)
		p.advanceTokens()
	}

	for !(p.peekToken.Token_type == l.SEMICOLON) && precedence < p.peekPrecedence() {
		infixParseFn, exist := p.infixParseFns[p.peekToken.Token_type]
		if !exist {
			return leftExpression
		}

		p.advanceTokens()
		if leftExpression == nil {
			panic("left expression cannot be nil while parsing a expression")
		}

		leftExpression = infixParseFn(leftExpression)
	}

	return leftExpression
}

// parse a expression statement
func (p *Parser) parserExpressionStatement() *ast.ExpressionStament {
	p.checkCurrentTokenIsNotNil()
	expressionStament := ast.NewExpressionStament(*p.currentToken, nil)
	expressionStament.Expression = p.parseExpression(LOWEST)

	if p.peekToken == nil {
		panic("peek token cannot be bil")
	}
	if p.peekToken.Token_type == l.SEMICOLON {
		p.advanceTokens()
	}

	return expressionStament
}

// parse group expression like (5 + 5) / 2
func (p *Parser) parseGroupExpression() ast.Expression {
	p.advanceTokens()
	expression := p.parseExpression(LOWEST)
	if !p.expepectedToken(l.RPAREN) {
		return nil
	}

	return expression
}

func (p *Parser) parseReassigment(ident ast.Expression) ast.Expression {
	p.checkCurrentTokenIsNotNil()
	reassignment := ast.NewReassignment(*p.currentToken, ident, nil)
	p.advanceTokens()
	reassignment.NewVal = p.parseExpression(LOWEST)
	return reassignment
}

// parse a function declaration
func (p *Parser) parseFunction() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	function := ast.NewFunction(*p.currentToken, nil)
	if !p.expepectedToken(l.LPAREN) {
		return nil
	}

	function.Parameters = p.parseFunctionParameters()
	if !p.expepectedToken(l.LBRACE) {
		return nil
	}

	function.Body = p.parseBlock()
	return function
}

// parse function parameters and check the syntax
func (p *Parser) parseFunctionParameters() []*ast.Identifier {
	var params []*ast.Identifier
	p.checkPeekTokenIsNotNil()
	if p.peekToken.Token_type == l.RPAREN {
		p.advanceTokens()
		return params
	}

	p.advanceTokens()
	identifier := ast.NewIdentifier(*p.currentToken, p.currentToken.Literal)
	params = append(params, identifier)

	for p.peekToken.Token_type == l.COMMA {
		p.advanceTokens()
		p.advanceTokens()
		identifier = ast.NewIdentifier(*p.currentToken, p.currentToken.Literal)
		params = append(params, identifier)
	}

	if !p.expepectedToken(l.RPAREN) {
		return make([]*ast.Identifier, 0)
	}

	return params
}

// parse a identifier
func (p *Parser) parseIdentifier() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	return &ast.Identifier{Token: *p.currentToken, Value: p.currentToken.Literal}
}

// parse infix expressoins
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	p.checkCurrentTokenIsNotNil()
	infix := ast.Newinfix(*p.currentToken, nil, p.currentToken.Literal, left)
	precedence := p.currentPrecedence()
	p.advanceTokens()
	infix.Rigth = p.parseExpression(precedence)
	return infix
}

func (p *Parser) parseRangeExpression() ast.Expression {
	rangeExpress := ast.NewRange(*p.currentToken, nil, nil)
	if !p.expepectedToken(l.IDENT) {
		return nil
	}

	rangeExpress.Variable = p.parseIdentifier()
	if !p.expepectedToken(l.IN) {
		return nil
	}

	p.advanceTokens()
	rangeExpress.Range = p.parseExpression(LOWEST)
	return rangeExpress
}

func (p *Parser) parseFor() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	forExpression := ast.NewFor(*p.currentToken, nil, nil)
	if !p.expepectedToken(l.LPAREN) {
		return nil
	}

	forExpression.Condition = p.parseRangeExpression()
	if !p.expepectedToken(l.RPAREN) {
		return nil
	}
	if !p.expepectedToken(l.LBRACE) {
		return nil
	}

	forExpression.Body = p.parseBlock()
	return forExpression
}

func (p *Parser) parseCallList(valueList ast.Expression) ast.Expression {
	p.checkCurrentTokenIsNotNil()
	callList := ast.NewCallList(*p.currentToken, valueList, nil)
	p.advanceTokens()
	callList.Index = p.parseExpression(LOWEST)
	if !p.expepectedToken(l.RBRACKET) {
		return nil
	}

	return callList
}

func (p *Parser) parseWhile() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	whileExpression := ast.NewWhile(*p.currentToken, nil, nil)
	if !p.expepectedToken(l.LPAREN) {
		return nil
	}

	p.advanceTokens()
	whileExpression.Condition = p.parseExpression(LOWEST)
	if !p.expepectedToken(l.RPAREN) {
		return nil
	}

	if !p.expepectedToken(l.LBRACE) {
		return nil
	}

	whileExpression.Body = p.parseBlock()
	return whileExpression
}

// parse if expressions, check sintax and if there is an else in the expression
func (p *Parser) parseIf() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	ifExpression := ast.NewIf(*p.currentToken, nil, nil, nil)
	if !p.expepectedToken(l.LPAREN) {
		return nil
	}

	p.advanceTokens()
	ifExpression.Condition = p.parseExpression(LOWEST)
	if !p.expepectedToken(l.RPAREN) {
		return nil
	}

	if !p.expepectedToken(l.LBRACE) {
		return nil
	}

	ifExpression.Consequence = p.parseBlock()

	p.checkPeekTokenIsNotNil()
	if p.peekToken.Token_type == l.ELSE {
		p.advanceTokens()
		if !p.expepectedToken(l.LBRACE) {
			return nil
		}

		ifExpression.Alternative = p.parseBlock()
	}

	return ifExpression
}

func (p *Parser) parseSuffixFn(left ast.Expression) ast.Expression {
	return ast.NewSuffix(*p.currentToken, left, p.currentToken.Literal)
}

func (p *Parser) parseMethod(left ast.Expression) ast.Expression {
	p.checkCurrentTokenIsNotNil()
	method := ast.NewMethodExpression(*p.currentToken, left, nil)
	if !p.expepectedToken(l.IDENT) {
		return nil
	}

	method.Method = p.parseExpression(LOWEST)
	return method
}

// parse integer expressions
func (p *Parser) parseInteger() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	integer := ast.NewInteger(*p.currentToken, nil)

	val, err := strconv.Atoi(p.currentToken.Literal)
	if err != nil {
		message := fmt.Sprintf("no se pudo parsear %s como entero", p.currentToken.Literal)
		p.errors = append(p.errors, message)
		return nil
	}

	integer.Value = &val
	return integer
}

func (p *Parser) parseKeyValues() *ast.KeyValue {
	p.checkCurrentTokenIsNotNil()
	keyVal := ast.NewKeyVal(*p.currentToken, nil, nil)
	keyVal.Key = p.parseExpression(LOWEST)
	if !p.expepectedToken(l.ARROW) {
		return nil
	}

	p.advanceTokens()
	keyVal.Value = p.parseExpression(LOWEST)
	return keyVal
}

func (p *Parser) parseMap() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	mapExpress := ast.NewMapExpression(*p.currentToken, []*ast.KeyValue{})
	if !p.expepectedToken(l.LBRACE) {
		return nil
	}

	p.advanceTokens()
	keyVal := p.parseKeyValues()
	if keyVal == nil {
		return nil
	}

	mapExpress.Body = append(mapExpress.Body, keyVal)
	for p.peekToken.Token_type == l.COMMA {
		p.advanceTokens()
		p.advanceTokens()
		keyVal := p.parseKeyValues()
		if keyVal == nil {
			return nil
		}

		mapExpress.Body = append(mapExpress.Body, keyVal)
	}
	p.advanceTokens()
	return mapExpress
}

func (p *Parser) ParseNull() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	return ast.NewNull(*p.currentToken)
}

// parse given let stament and check sintax
func (p *Parser) parseLetSatement() ast.Stmt {
	p.checkCurrentTokenIsNotNil()
	stament := ast.NewLetStatement(*p.currentToken, nil, nil)
	if !p.expepectedToken(l.IDENT) {
		return nil
	}

	stament.Name = p.parseIdentifier().(*ast.Identifier)
	if !p.expepectedToken(l.ASSING) {
		return nil
	}

	p.advanceTokens()
	stament.Value = p.parseExpression(LOWEST)
	p.checkPeekTokenIsNotNil()
	if p.peekToken.Token_type == l.SEMICOLON {
		p.advanceTokens()
	}

	return stament
}

// parse a prefix expression
func (p *Parser) parsePrefixExpression() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	prefixExpression := ast.NewPrefix(*p.currentToken, p.currentToken.Literal, nil)
	p.advanceTokens()
	prefixExpression.Rigth = p.parseExpression(PREFIX)
	return prefixExpression
}

// parse given return stament
func (p *Parser) parseReturnStatement() ast.Stmt {
	p.checkCurrentTokenIsNotNil()
	stament := ast.NewReturnStatement(*p.currentToken, nil)
	p.advanceTokens()

	stament.ReturnValue = p.parseExpression(LOWEST)
	p.checkPeekTokenIsNotNil()
	if p.peekToken.Token_type == l.SEMICOLON {
		p.advanceTokens()
	}

	return stament
}

// check current token and parse the token as a expression, let stament or return stament
func (p *Parser) parseStament() ast.Stmt {
	p.checkCurrentTokenIsNotNil()
	if p.currentToken.Token_type == l.LET {
		return p.parseLetSatement()
	} else if p.currentToken.Token_type == l.RETURN {
		return p.parseReturnStatement()
	}

	return p.parserExpressionStatement()
}

func (p *Parser) parseStringLiteral() ast.Expression {
	p.checkCurrentTokenIsNotNil()
	return ast.NewStringLiteral(*p.currentToken, p.currentToken.Literal)
}

// check the precedence of the current token
func (p *Parser) peekPrecedence() Precedence {
	p.checkPeekTokenIsNotNil()
	precedence, exists := PRECEDENCES[p.peekToken.Token_type]
	if !exists {
		return LOWEST
	}

	return precedence
}

// register all infix functions for the different token types
func (p *Parser) registerInfixFns() InfixParseFns {
	inFixFns := make(InfixParseFns)
	inFixFns[l.PLUS] = p.parseInfixExpression
	inFixFns[l.MINUS] = p.parseInfixExpression
	inFixFns[l.COLON] = p.parseMethod
	inFixFns[l.DIVISION] = p.parseInfixExpression
	inFixFns[l.TIMES] = p.parseInfixExpression
	inFixFns[l.EQ] = p.parseInfixExpression
	inFixFns[l.NOT_EQ] = p.parseInfixExpression
	inFixFns[l.GTOREQ] = p.parseInfixExpression
	inFixFns[l.LTOREQ] = p.parseInfixExpression
	inFixFns[l.LT] = p.parseInfixExpression
	inFixFns[l.IN] = p.parseInfixExpression
	inFixFns[l.GT] = p.parseInfixExpression
	inFixFns[l.PLUSASSING] = p.parseInfixExpression
	inFixFns[l.MINUSASSING] = p.parseInfixExpression
	inFixFns[l.TIMEASSI] = p.parseInfixExpression
	inFixFns[l.DIVASSING] = p.parseInfixExpression
	inFixFns[l.EXPONENT] = p.parseInfixExpression
	inFixFns[l.LPAREN] = p.parseCall
	inFixFns[l.ASSING] = p.parseReassigment
	inFixFns[l.LBRACKET] = p.parseCallList
	inFixFns[l.MOD] = p.parseInfixExpression
	inFixFns[l.AND] = p.parseInfixExpression
	inFixFns[l.OR] = p.parseInfixExpression
	return inFixFns
}

// register all prefix functions for the different token types
func (p *Parser) registerPrefixFns() PrefixParsFns {
	prefixFns := make(PrefixParsFns)
	prefixFns[l.FALSE] = p.parseBoolean
	prefixFns[l.FOR] = p.parseFor
	prefixFns[l.FUNCTION] = p.parseFunction
	prefixFns[l.WHILE] = p.parseWhile
	prefixFns[l.IDENT] = p.parseIdentifier
	prefixFns[l.IF] = p.parseIf
	prefixFns[l.INT] = p.parseInteger
	prefixFns[l.LPAREN] = p.parseGroupExpression
	prefixFns[l.MINUS] = p.parsePrefixExpression
	prefixFns[l.NOT] = p.parsePrefixExpression
	prefixFns[l.TRUE] = p.parseBoolean
	prefixFns[l.STRING] = p.parseStringLiteral
	prefixFns[l.DATASTRCUT] = p.ParseArray
	prefixFns[l.NULLT] = p.ParseNull
	prefixFns[l.MAP] = p.parseMap
	return prefixFns
}

func (p *Parser) registerSuffixFns() SuffixParseFns {
	suffixFns := make(SuffixParseFns)
	suffixFns[l.EXPONENT] = p.parseSuffixFn
	suffixFns[l.PLUS2] = p.parseSuffixFn
	suffixFns[l.MINUS2] = p.parseSuffixFn
	return suffixFns
}
